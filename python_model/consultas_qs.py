# -*- coding: utf-8 -*-
"""consultas_qs

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MjY8C5d6ahTklf0lkCPFWZEcD4mLhFeV
"""

# -*- coding: utf-8 -*-
import pandas as pd
import json
import sys
import os

# Ruta dinámica del archivo
ruta_actual = os.path.join(os.getcwd(), "python_model")
ruta_csv = os.path.join(ruta_actual, "qs World University Rankings 2025 (Top global universities).csv")

try:
    df = pd.read_csv(ruta_csv, encoding="latin1")
    df.columns = df.columns.str.strip()
except Exception as e:
    print(json.dumps({"error": f"Error al cargar CSV: {str(e)}"}))
    sys.exit(1)

# Entrada desde backend
pregunta = sys.argv[1].strip().lower() if len(sys.argv) > 1 else ""

# Diccionario base
comandos = {
    "mejor puntaje": ("Overall_Score", "max"),
    "mejor reputacion": ("Academic_Reputation_Score", "max"),
    "mejor ranking": ("RANK_2025", "min"),
    "mejor red internacional": ("International_Research_Network_Score", "max"),
    "mas internacionales": ("International_Students_Score", "max"),
    "mas citas": ("Citations_per_Faculty_Score", "max"),
    "mejor empleabilidad": ("Employment_Outcomes_Score", "max"),
    "mas sostenible": ("Sustainability_Score", "max")
}

# Validación
if pregunta not in comandos:
    print(json.dumps({"error": f"No se reconoce la consulta '{pregunta}'."}))
    sys.exit(1)

columna, tipo = comandos[pregunta]

# Validar si la columna existe
if columna not in df.columns:
    print(json.dumps({"error": f"La columna '{columna}' no existe en el archivo CSV."}))
    sys.exit(1)

# Filtrado con tolerancia a valores NaN
df_filtrado = df[df[columna].notna()]
if df_filtrado.empty:
    print(json.dumps({"error": f"No hay datos válidos para la columna '{columna}'."}))
    sys.exit(1)

try:
    resultado = df_filtrado[df_filtrado[columna] == df_filtrado[columna].max()] if tipo == "max" else df_filtrado[df_filtrado[columna] == df_filtrado[columna].min()]
    resumen = resultado[[
        "Institution_Name", "RANK_2025", "Overall_Score", "Location"
    ]].to_dict(orient="records")

    print(json.dumps(resumen, indent=2, ensure_ascii=False))
except Exception as e:
    print(json.dumps({"error": f"Error al procesar datos: {str(e)}"}))
